machine(MachineType:L0Cache, "MSI Directory SCache")
    :   Sequencer * sequencer;
        CacheMemory * Scache;
        Cycles request_latency := 2;
        Cycles response_latency := 2;
        bool send_evictions;

        RubyPrefetcher * prefetcher;
        bool enable_prefetch := "False";

        //从该节点的L0缓存到网络
        MessageBuffer * bufferToL1, network="To";

        //从网络到该节点的L0缓存
        MessageBuffer * bufferFromL1, network="From";

        //此控制器和处理器之间的消息队列
        MessageBuffer * mandatoryQueue;

        //用于预取的请求缓冲区
        MessageBuffer * prefetchQueue;
{
    state_declaration(State, desc="Cache states", default="L0Cache_State_I") {
        // The cache entry has not been allocated. 尚未分配缓存项。
        I, AccessPermission:Invalid, desc="Invalid（无效）";

        // The cache entry is in shared mode. The processor can read this entry
        // but it cannot write to it. 缓存项处于共享模式。处理器可以读取此条目，但不能写入。
        S, AccessPermission:Read_Only, desc="Shared（清洁共享）";

        // The processor has read and write permissions on this entry.处理器对此条目具有读写权限。
        M, AccessPermission:Read_Write, desc="Modified（脏独占）";

        /***********Transient States状态转换**************/
        //I-->I   ack    Evict* 的请求（EvictLoaclBlk,EvictGlobalBlk,EvictECacheBlk）
        IIA, AccessPermission:Busy, desc="Issued Evict* request, wait for ChangeToDirtyFail Ack";

        //I-->I   data   响应无数据？??
        IID, AccessPermission:Busy, desc="Get putinvalid, wait for NoDataResponse";

        // The cache controller has requested that this entry be fetched in
        // shared state so that the processor can read it. 缓存控制器已请求以共享状态获取此条目，以便处理器可以读取它。
        //I-->S   data
        ISD, AccessPermission:Busy, desc="Issued GETS, have not seen response yet(尚未收到回复)";

        // The cache controller has requested that this entry be fetched in
        // modify state so that the processor can read/write it. //高速缓存控制器已请求在脏状态下获取该条目，以便处理器可以读取/写入该条目。
        //I-->M   ack
        IMA, AccessPermission:Busy, desc="Issued davi, have not seen response yet";

        //I-->M    data
        IMD, AccessPermission:Busy, desc="Issued davi, have not seen response yet";

        //I-->E    ack
        IEA, AccessPermission:Busy, desc="Issued EvictLocalBlk/EvictECacheBlk, have not seen response yet";

        // The cache controller had read permission over the entry. But now the
        // processor needs to write to it. So, the controller has requested for
        // write permission. 缓存控制器对该项具有读取权限。但现在处理器需要写入它。因此，控制器已请求写入权限
        //S-->M     ack
        SMA, AccessPermission:Read_Only, desc="Issued GETX, have not seen response yet";
        //S-->M     data
        SMD, AccessPermission:Read_Only, desc="Issued GETX, have not seen response yet";

        //S-->I     data
        SID, AccessPermission:Busy, desc="Received putinvalid, have not seen response yet";
        
        //S-->I     data    ack
        SIDA, AccessPermission:Busy, desc="Received putinvalid, have not seen response yet";

        //S-->S
        SS, AccessPermission:Read_Only, desc="Issued EVICT*, have not seen response yet";

        //M-->S     data
        MSD, AccessPermission:Busy, desc="Received GETS, have not seen response yet";

        //M-->I     data
        MID, AccessPermission:Busy, desc="Received GETS, have not seen response yet";

        //M-->M     ack
        MMA, AccessPermission:Busy, desc="Issued EvictGlobalBlk/EvictECacheBlk, have not seen response yet";

        // Transient states in which block is being prefetched正在预取块的瞬态状态
        PF_FA, AccessPermission:Busy, desc="Issued GETS, have not seen response yet";
        PF_WA, AccessPermission:Busy, desc="Issued GETS, have not seen response yet";
    }

    enumeration(Event, desc="Cache events") {
        // Events from core  来自核心的事件
        Load,                       desc="Load request from the home processor来自主处理器的加载请求";
        ReadNCBlk,                  desc="uncached Load request from the home processor来自主处理器的未缓存加载请求";
        Ifetch,                     desc="I-fetch request from the home processor 来自home处理器的I-fetch请求";
        Store_miss,                 desc="Store request from the home processor";
        Store_hit,                  desc="Store request from the home processor";
        WriteNCBlk,                 desc="uncached Store";

        // requests from LCPM (due to self or other core) LCPM的（二次）请求（由于自身或其他核心）
        GSN_PUTINV,                 desc="set Data Invalid ";
        GSN_GETINV,                 desc="Get Data and set Invalid gsn from LCPM";
        GSN_GETS,                   desc="Get Data and set shared gsn from LCPM";
        GSN_GETRELEASE,             desc="Get Data and release(释放缓冲) gsn from LCPM";
        GSN_NCGETRELEASE,           desc="nocache addr Get Data and release gsn from LCPM";
        GSN_RELEASE,                desc="Release gsn from LCPM";

        // internal generated request 内部生成的请求
        WrVictimBlk_R,              desc="Scache cache line Replacement", format="!r";

        //Replacement 刷新
        EvictLocalBlk_R,            desc="L0 Replacement, Scache cache line Replacement", format="!r";
        EvictECacheBlk_R,           desc="Scache cache line Replacement", format="!r";

        //FLUSH
        EvictGlobalBlk_R,           desc="Scache cache line Replacement", format="!r";

        //rsp for gsn(rq2), for processor   二次请求的回答
        Data_Response,              desc="Data for processor";
        NoData_Response,            desc="Data for processor, but not for storage";

        //ack for grq(rq1), for processor   一次请求的响应
        ReadData_Ack,               desc="Ack envents for FetchBlkI,IORead";
        ReadNCData_Ack,             desc="Ack events for ReadNCBlk"
        ReadDataShare_Ack,          desc="Ack for ReadBlkI,ReadBlkIDVic,ReadBlk,ReadBlkDVic";
        ReadDataDirty_Ack,          desc="ReadBlkMod, ReadBlkDVic";
        ChangeToDirtySuccess_Ack,   desc="ShareToDirty";
        ChangeToDirtyFail_Ack,      desc="ShareToDirty fail, EvictECacheBlk,EvictLocalBlk,EvictECacheBlk";
        WriteComplete_Ack,          desc="WrVictimBlk,IOWrite";
        WriteNCComplete_Ack,        desc="WriteNCBlk, WriteNCComplete_Ack";
        RequestComplete_Ack,        desc="";
        IllegalAddr_Ack,            desc="地址非法";
        INTReq_Ack,                 desc="向核心发送的中断请求";

        // Prefetch events (generated by prefetcher) 预取事件（由预取器生成）
        PF_L0_Replacement,          desc="L0 Replacement caused by pretcher", format="!pr";
        ECFetchBlk_R,               desc="Load request from prefetcher";
        ECFetchBlkMod_R,            desc="Instruction fetch request from prefetcher";
        PF_Bad_Addr,                desc="Throw away prefetch request due to bad address generation";
    }


    // TBE fields 字段
    structure(TBE, desc="...") {
        Addr addr,                      desc="Physical address for this TBE";
        State TBEState,                 desc="Transient state";
        DataBlock DataBlk,              desc="Buffer for the data block";
        bool Dirty, default="false",    desc="data is dirty";
        int pendingAcks, default="0",   desc="number of pending acks";
    }

    structure(TBETable, external="yes") {
        TBE lookup(Addr);
        void allocate(Addr);
        void deallocate(Addr);
        bool isPresent(Addr);
        TBE getNullEntry();
    }

    //TODO:定义全局变量
    TBETable TBEs, template="<L0Cache_TBE>", constructor="m_number_of_TBEs";

    //获取Scache条目
    Entry getSCacheEntry(Addr addr), return_by_pointer="yes" {
        Entry Scache_entry := static_cast(Entry, "pointer", Scache[addr]);
        return Scache_entry;
    }

    //[29] == 0     EvictLocalBlk 刷新SCache
    //[29] == 1     EvictECacheBlk 核外刷新TCache
    //TODO ： 为啥是29位 bool型返回会不会更好
    int getEvictType(Addr addr) {
        return(addr >> 29 & 0x01);
    }

    //地址待定，可自己设置，后期以文档为准
    int isCached(Addr addr) {
        return(addr >> 47 & 0x01); 
    }

    //参数：请求类型 、 地址 、 是否命中 、 是否淘汰
    Event mandatory_request_type_to_event(RubyRequestType type, Addr addr, bool is_hit, bool is_vic) {
        if (type == RubyRequestType:LD) {   //请求类型:装载(数据流)
            if(isCached(addr)) {            //可Cache
                if(is_vic)                  //淘汰
                    return Event:ReadBlkDVic;   //带脏淘汰的存储器读请求
                else
                    return Event:Load;      //ReadBlk  存储器读请求
            } else {                        //不可Cache
                return Event:ReadNCBlk;     //不可Cache读请求
            }
        } else if (type == RubyRequestType:IFETCH) {    //请求类型：取值令
            if(is_vic)                      //淘汰
                return Event:ReadBlkIDVic;  //带脏淘汰的取值令请求
            else
                return Event:Ifetch;        //ReadBlkI  取值令请求
        //请求类型：存储 || 原子加载/存储———已取消 || 存储条件
        } else if ((type == RubyRequestType:ST) || (type == RubyRequestType:ATOMIC) || (type == RubyRequestType:Store_Conditional)) {
            if(isCached(addr)) {            //可Cache
                if(is_hit)                  //命中
                    return Event:Store_hit; //写命中
                else if(is_vic) {           //不命中且淘汰
                    return Event:ReadBlkModDVic;    //带脏淘汰的存储器修改读请求
                } else
                    return Event:Store_miss;        //写MISS               
            } else                          //不可Cache
                return Event:WriteNCBlk;    //不可Cache写请求              
        } else {
            error("Invalid RubyRequestType");       //无效的请求类型
        }
    }


    //将bufferToL1和prefetchQueue 重命名为 requestNetwork_out和optionalQueue_out
    out_port(requestNetwork_out, CoherenceMsg, bufferToL1);
    out_port(optionalQueue_out, RubyRequest, prefetchQueue);

    //控制器和预取器之间的预取队列根据Spracklen等人（HPCA 2005），
    //预取队列应实现为后进先出结构。该结构将允许快速搜索队列中的所有条目，
    //而不仅仅是标题消息。如果需求未命中，结构中的所有消息都将失效。
    //rank 优先级为2
    in_port(optionalQueue_in, RubyRequest, prefetchQueue, desc="...", rank = 2) {
        if (optionalQueue_in.isReady(clockEdge())) {
            peek(optionalQueue_in, RubyRequest) {
                // first check for valid address
                MachineID mid := mapAddressToMachine(in_msg.LineAddress, MachineType:Directory);
                NodeID nid := machineIDToNodeID(mid);
                int nidint := IDToInt(nid);
                int numDirs := machineCount(MachineType:Directory);
                if (nidint >= numDirs) {
                    Entry cache_entry := static_cast(Entry, "pointer", Scache.getNullEntry());
                    TBE tbe := TBEs.getNullEntry();
                    trigger(Event:PF_Bad_Addr, in_msg.LineAddress, cache_entry, tbe);
                } else if (in_msg.Type == RubyRequestType:IFETCH) {
                    // Instruction Prefetch
                    Entry icache_entry := getSCacheEntry(in_msg.LineAddress);
                    if (is_valid(icache_entry)) {
                        // The block to be prefetched is already present in the
                        // cache. This request will be made benign and cause the
                        // prefetch queue to be popped.
                        trigger(prefetch_request_type_to_event(in_msg.Type),
                            in_msg.LineAddress, icache_entry, TBEs[in_msg.LineAddress]);
                    }

                    // Check to see if it is in the L0-D
                    Entry cache_entry := getSCacheEntry(in_msg.LineAddress);
                    if (is_valid(cache_entry)) {
                        // The block is in the wrong L0 cache. We should drop
                        // this request.
                        trigger(prefetch_request_type_to_event(in_msg.Type),
                            in_msg.LineAddress, cache_entry, TBEs[in_msg.LineAddress]);
                    }

                    if (Icache.cacheAvail(in_msg.LineAddress)) {
                        // L0-I does't have the line, but we have space for it
                        // in the L0-I so let's see if the L1 has it
                        trigger(prefetch_request_type_to_event(in_msg.Type),
                            in_msg.LineAddress, icache_entry, TBEs[in_msg.LineAddress]);
                    } else {
                        // No room in the L0-I, so we need to make room in the L0-I
                        Addr addr := Icache.cacheProbe(in_msg.LineAddress);
                        check_on_cache_probe(optionalQueue_in, addr);

                        trigger(Event:PF_L0_Replacement, addr,
                            getICacheEntry(addr), TBEs[addr]);
                    }
                } else {
                    // Data prefetch
                    Entry cache_entry := getSCacheEntry(in_msg.LineAddress);
                    if (is_valid(cache_entry)) {
                        // The block to be prefetched is already present in the
                        // cache. This request will be made benign and cause the
                        // prefetch queue to be popped.
                        trigger(prefetch_request_type_to_event(in_msg.Type),
                            in_msg.LineAddress, cache_entry, TBEs[in_msg.LineAddress]);
                    }

                    // Check to see if it is in the L0-I
                    Entry icache_entry := getICacheEntry(in_msg.LineAddress);
                    if (is_valid(icache_entry)) {
                        // The block is in the wrong L0. Just drop the prefetch
                        // request.
                        trigger(prefetch_request_type_to_event(in_msg.Type),
                            in_msg.LineAddress, icache_entry, TBEs[in_msg.LineAddress]);
                    }

                    if (Scache.cacheAvail(in_msg.LineAddress)) {
                        // L0-D does't have the line, but we have space for it in
                        // the L0-D let's see if the L1 has it
                        trigger(prefetch_request_type_to_event(in_msg.Type),
                            in_msg.LineAddress, cache_entry, TBEs[in_msg.LineAddress]);
                    } else {
                        // No room in the L0-D, so we need to make room in the L0-D
                        Addr addr := Scache.cacheProbe(in_msg.LineAddress);
                        check_on_cache_probe(optionalQueue_in, addr);

                        trigger(Event:PF_L0_Replacement, addr,
                            getSCacheEntry(addr), TBEs[addr]);
                    }
                }
            }
        }
    }

    // Messages for this L0 cache from the L1 cache
    in_port(messgeBuffer_in, CoherenceMsg, bufferFromL1, rank = 1) {
        if (messgeBuffer_in.isReady(clockEdge())) {
            peek(messgeBuffer_in, CoherenceMsg, block_on="addr") {
                assert(in_msg.Dest == machineID);
                TBE tbe := TBEs[in_msg.addr];

                Entry cache_entry := getCacheEntry(in_msg.addr);

                if(in_msg.Class == CoherenceClass:ReadData) {
                    if(isCached(in_msg.addr))
                        trigger(Event:ReadData_Ack, in_msg.addr, cache_entry, tbe);
                    else {
                        tbe.DataBlk := in_msg.DataBlk;
                        trigger(Event:ReadNCData_Ack, in_msg.addr, cache_entry, tbe);
                    }
                } else if(in_msg.Class == CoherenceClass:ReadDataShare) {
                    trigger(Event:ReadDataShare_Ack, in_msg.addr, cache_entry, tbe);
                } else if(in_msg.Class == CoherenceClass:ReadDataDirty) {
                    trigger(Event:ReadDataDirty_Ack, in_msg.addr, cache_entry, tbe);
                } else if(in_msg.Class == CoherenceClass:ChangeToDirtySuccess) {
                    trigger(Event:ChangeToDirtySuccess_Ack, in_msg.addr, cache_entry, tbe);
                } else if(in_msg.Class == CoherenceClass:ChangeToDirtyFail_Ack) {
                    trigger(Event:ChangeToDirtyFail_Ack, in_msg.addr, cache_entry, tbe);
                } else if(in_msg.Class == CoherenceClass:GetR) {
                    if(isCached(in_msg.addr))
                        trigger(Event:GSN_GETRELEASE, in_msg.addr, cache_entry, tbe);
                    else
                        trigger(Event:GSN_NCGETRELEASE, in_msg.addr, cache_entry, tbe);
                } else if (in_msg.Class == CoherenceClass:PutI) {
                    trigger(Event:GSN_PUTINV, in_msg.addr, cache_entry, tbe);
                } else if (in_msg.Class == CoherenceClass:WriteComplete) {
                    if(isCached(in_msg.addr))
                        trigger(Event:WriteComplete_Ack, in_msg.addr, cache_entry, tbe);
                    else
                        trigger(Event:WriteNCComplete_Ack, in_msg.addr, cache_entry, tbe);
                } else if (in_msg.Class == CoherenceClass:GetI) {
                    trigger(Event:GSN_GETINV, in_msg.addr, cache_entry, tbe);
                } else if (in_msg.Class == CoherenceClass:GetS) {
                    trigger(Event:GSN_GETS, in_msg.addr, cache_entry, tbe);
                } else if (in_msg.Class == CoherenceClass:GETX || in_msg.Class == CoherenceClass:UPGRADE) {
                    // upgrade transforms to GETX due to race
                    trigger(Event:Fwd_GETX, in_msg.addr, cache_entry, tbe);
                } else if (in_msg.Class == CoherenceClass:Release) {
                    trigger(Event:GSN_RELEASE, in_msg.addr, cache_entry, tbe);
                } else if (in_msg.Class == CoherenceClass:RequestComplete) {
                    trigger(Event:RequestComplete_Ack, in_msg.addr, cache_entry, tbe);
                } else {
                    error("Invalid forwarded request type");
                }
            }
        }
    }

    // Mandatory Queue betweens Node's CPU and it's L0 caches 节点的CPU与其L0缓存之间的强制队列
    in_port(mandatoryQueue_in, RubyRequest, mandatoryQueue, desc="...", rank = 0) {
        if (mandatoryQueue_in.isReady(clockEdge())) {
            peek(mandatoryQueue_in, RubyRequest, block_on="LineAddress") {
                // Check for data access to blocks in I-cache and ifetchs to blocks in D-cache
                // 检查对I-cache中的块的数据访问和对D-cache的块的ifetch
                if (in_msg.Type == RubyRequestType:IFETCH) {
                    // ** INSTRUCTION ACCESS  指令存取***
                    Entry Scache_entry := getSCacheEntry(in_msg.LineAddress);
                    if (is_valid(Scache_entry)) {   //Scache条目有效
                        // The tag matches for the L0, so the L0 asks the L2 for it.
                        // 标签与L0匹配，因此L0向L2请求它。
                        // 触发的事件:Ifetch 取值令请求
                        trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress, true, false), 
                            in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                    } else {    //Scache条目无效
                        //Scache missed  SCache不命中 
                        if (Scache.cacheAvail(in_msg.LineAddress)) {    //Cache有空间
                            // L0 does't have the line, but we have space for it
                            // in the L0 so let's see if the L2 has it
                            // L0没有线条，但我们在L0中有空间，所以让我们看看L2是否有线条
                            // 触发的事件:Ifetch 取值令请求
                            trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress, false, false), 
                                in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                        } else {
                            // No room in the L0, so we need to make room in the L0
                            // Check if the line we want to evict is not locked
                            // L0中没有空间，所以我们需要在L0中腾出空间。检查我们要驱逐的线路是否未锁定
                            Addr addr := Scache.cacheProbe(in_msg.LineAddress);  //准备淘汰的地址
                            check_on_cache_probe(mandatoryQueue_in, addr);       //地址是否在缓冲队列中
                            Scache_entry := getSCacheEntry(addr);           
                            //触发的事件：ReadBlkDVic
                            trigger(mandatory_request_type_to_event(in_msg.Type, addr ,false, true), 
                                addr, Scache_entry, TBEs[in_msg.LineAddress]);
                        }
                    }
                //Type：刷新
                } else if (in_msg.Type == RubyRequestType:REPLACEMENT) {
                    // No room in the L1, so we need to make room in the L0
                    // Check if the line we want to evict is not locked
                    // L1中没有空间，所以我们需要在L0中腾出空间。检查我们要驱逐的线路是否未锁定
                    Entry Scache_entry := getSCacheEntry(in_msg.LineAddress);
                    Addr addr := Scache.cacheProbe(in_msg.LineAddress);
                    check_on_cache_probe(mandatoryQueue_in, addr);
                    if (getEvictType(addr))
                        //触发事件:EvictECacheBlk_R
                        trigger(Event:EvictECacheBlk_R, in_msg.LineAddress, Scache_entry , TBEs[in_msg.LineAddress]);
                    else {
                        //Scache条目有效
                        if (is_valid(Scache_entry))
                            //触发事件:EvictLocalBlk_R
                            trigger(Event:EvictLocalBlk_R, addr, getSCacheEntry(addr), TBEs[addr]);
                    }
                //Type:刷新请求类型
                } else if (in_msg.Type == RubyRequestType:FLUSH) {
                    if(is_valid(Scache_entry))
                        //触发事件:EvictGlobalBlk_R
                        trigger(Event:EvictGlobalBlk_R, addr, getSCacheEntry(addr), TBEs[addr]);
                } else {//其他类型
                    // *** DATA ACCESS ***
                    // 不可Cache
                    if(!isCached(in_msg.LineAddress)) {
                        //可能触发的事件:  ReadNCBlk/WriteNCBlk  判断type:LD/ST  
                        trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress, true, false), 
                            in_msg.LineAddress, Scache_entry, tbe);
                    } else {
                        Entry Scache_entry := getSCacheEntry(in_msg.LineAddress);
                        // early out for failed store conditionals
                        // 及早发现失败的存储条件
                        if (in_msg.Type == RubyRequestType:Store_Conditional) { //不用管，这是ARM的东西，可以不用看
                            //TODO:这个判断条件是啥意思
                            if (!sequencer.llscCheckMonitor(in_msg.LineAddress)) {
                                //触发的事件:Failed_SC
                                trigger(Event:Failed_SC, in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                            }
                        }
                        if (is_valid(Scache_entry)) {   //有效-->命中
                            // The tag matches for the L0, so the L0 ask the L1 for it
                            // 标签与L0匹配，因此L0向L1请求它
                            // 触发的事件:  Load/Store_hit  判断type:LD/ST 
                            trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress, true, false), 
                                in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                        } else {
                            // if the request is not valid, the store conditional will fail
                            // 如果请求无效，存储条件将失败
                            if (in_msg.Type == RubyRequestType:Store_Conditional) { //不用管，这是ARM的东西，可以不用看
                                // if the line is not valid, it can't be locked
                                // 如果该行无效，则无法锁定
                                // 触发的事件: Failed_SC
                                trigger(Event:Failed_SC, in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                            } else {
                                if (Scache.cacheAvail(in_msg.LineAddress)) {    //Cache是否有空间
                                    // L1 does't have the line, but we have space for it
                                    // in the L0 let's see if the L1 has it
                                    // L1没有线条，但我们在L0中有空间，让我们看看L1是否有空间
                                    // 触发的事件:  Load/Store_miss   判断type:LD/ST 
                                    trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress,false, false), 
                                        in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                                } else {
                                    // No room in the Scache, so we need to make room in the Scache
                                    // Check if the line we want to evict is not locked
                                    // Scache没有空间，所以我们需要在Scache腾出空间检查我们要驱逐的线路是否没有锁定
                                    Addr addr := Scache.cacheProbe(in_msg.LineAddress);
                                    check_on_cache_probe(mandatoryQueue_in, addr);
                                    Scache_entry := getSCacheEntry(addr);
                                    // 触发的事件:ReadBlkDVic/ReadBlkModDVic    判断type:LD/ST 
                                    trigger(mandatory_request_type_to_event(in_msg.Type, addr, false, true), 
                                        in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //a_issueReadBlk 行为
    //"a" 是啥意思
    action(a_issueReadBlk, "a", desc="Issue ReadBlk") {
        // 用于提取消息队列开头的消息的函数。该函数假定队列为非空。
        // 第一个参数：消息队列   第二个参数：消息类型
        peek(mandatoryQueue_in, RubyRequest) {
            // enqueue(信息，当前时间，请求等待时间)
            //TODO: 参数都没使用？？？？/参数对吗
            enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
                out_msg.addr := address;                        //输出信息的地址
                out_msg.Class := CoherenceClass:ReadBlk;        //输出信息的类型
                out_msg.Sender := machineID;                    //输出信息的机器码
                out_msg.Dest := createMachineID(MachineType:L1Cache, version);
                DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                    address, out_msg.Dest);
                out_msg.MessageSize := MessageSizeType:Control; //消息大小
                out_msg.AccessMode := in_msg.AccessMode;        //访问模式
            }
        }
    }

    //发出驱逐令
    //"isev"这个是干嘛用的
    action(issue_evict, "isev", desc="issue vic info to L1") {
        enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
            //为什么又要重复做一遍
            Addr addr := Scache.cacheProbe(address);        //准备淘汰的地址
            check_on_cache_probe(mandatoryQueue_in, addr);  //地址是否在缓冲队列中

            assert(is_valid(cache_entry));      //TODO:断言？cache条目是否有效？干嘛用的
            out_msg.addr := addr;
            if(cache_entry.Dirty) //如果Cache条目脏的？ 
                //TODO:class是干嘛的，Cache回写请求？  信息的类型？ 那NOP呢
                out_msg.Class := CoherenceClass:WrVictimBlk;    
            else
                out_msg.Class := Nop;
            //输出口的数据有啥需要考虑的吗，或者要求
            out_msg.Dirty := cache_entry.Dirty;
            out_msg.Sender:= machineID;
            out_msg.Dest := createMachineID(MachineType:L1Cache, version);  
            out_msg.MessageSize := MessageSizeType:Writeback_Control;

            //检查TBEs？？
            check_allocate(TBEs);
            //地址分配？
            TBEs.allocate(addr);
            //TODO
            set_tbe(TBEs[addr]);
            //淘汰？
            TBE tbe_evic := TBEs[addr];
            //这又是啥
            tbe_evic.DataBlk := cache_entry.DataBlk;
            //TODO:解除分配
            Scache.deallocate(addr);
            //TODO:这个函数。。。。
            unset_cache_entry();
        }
    }







    //local核心向LCPM发送 ReadBlkDVic(读产生的带脏淘汰取数请求)   I-->s  ====>   I-->ISD  ISD-->S
    transition(I, ReadBlkDVic, ISD) {
        // TODO:返回的类型ReadBlk？？ //其他的输出信息有要求吗/有些数据在哪来的
        a_issueReadBlk; 
        // send evict to lcpm & deallocate evict Scache & allocate tbe for evict addr
        // 发送驱逐到lcpm&解除分配驱逐Scache&为驱逐地址分配tbe
        issue_evict; 
        oo_allocateSCacheBlock; //for read
        i_uncache_allocateTBE; //for read
        uu_profileDataMiss;  //记录更新miss状态
        po_observeMiss;  //通知预取器cache miss
        k_popMandatoryQueue;  //弹出event
    }





}