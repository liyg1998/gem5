/*
 * Copyright (c) 2020 ARM Limited
 * All rights reserved
 *
 * The license below extends only to copyright in the software and shall
 * not be construed as granting a license to any other intellectual
 * property including but not limited to intellectual property relating
 * to a hardware implementation of the functionality of the software
 * licensed hereunder.  You may use the software subject to the license
 * terms below provided that you ensure that this notice is replicated
 * unmodified and in its entirety in all distributions of the software,
 * modified or unmodified, in source code or in binary form.
 *
 * Copyright (c) 2013 Mark D. Hill and David A. Wood
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

machine(MachineType:L0Cache, "MSI Directory SCache")
 : Sequencer * sequencer;
   CacheMemory * Scache;
   Cycles request_latency := 2;
   Cycles response_latency := 2;
   bool send_evictions;

   RubyPrefetcher * prefetcher;
   bool enable_prefetch := "False";

   // From this node's L0 cache to the network
   MessageBuffer * bufferToL1, network="To";

   // To this node's L0 cache FROM the network
   MessageBuffer * bufferFromL1, network="From";

   // Message queue between this controller and the processor
   MessageBuffer * mandatoryQueue;

   // Request Buffer for prefetches
   MessageBuffer * prefetchQueue;
{
  // STATES
  state_declaration(State, desc="Cache states", default="L0Cache_State_I") {
    // Base states

    // The cache entry has not been allocated.
    I, AccessPermission:Invalid, desc="Invalid";

    // The cache entry is in shared mode. The processor can read this entry
    // but it cannot write to it.
    S, AccessPermission:Read_Only, desc="Shared";

    // The processor has read and write permissions on this entry.
    M, AccessPermission:Read_Write, desc="Modified";

    // Transient States

    // The cache controller has requested that this entry be fetched in
    // shared state so that the processor can read it.
    ISD, AccessPermission:Busy, desc="Issued GETS, have not seen response yet";

    // The cache controller has requested that this entry be fetched in
    // modify state so that the processor can read/write it.
    IMD, AccessPermission:Busy, desc="Issued davi, have not seen response yet";

    IEA, AccessPermission:Busy, desc="Issued EvictLocalBlk/EvictECacheBlk, have not seen response yet";

    // The cache controller had read permission over the entry. But now the
    // processor needs to write to it. So, the controller has requested for
    // write permission.
    SMA, AccessPermission:Read_Only, desc="Issued GETX, have not seen response yet";
  
    // Transient states in which block is being prefetched
    PF_FA, AccessPermission:Busy, desc="Issued GETS, have not seen response yet";
    PF_WA, AccessPermission:Busy, desc="Issued GETS, have not seen response yet";
  }

  // EVENTS
  enumeration(Event, desc="Cache events") {
    // Events from core
    Load,            desc="Load request from the home processor";
    ReadBlkIDVic,    desc="";
    ReadBlkDVic,     desc="";
    ReadNCBlk,     desc="uncached Load request from the home processor";
    Ifetch,          desc="I-fetch request from the home processor";
    Store,           desc="Store request from the home processor";
    WriteNCBlk,    desc="uncached Store";
    // requests from LCPM (due to self or other core)
    GSN_PUTINV,   desc="set Data Invalid ";
    GSN_GETINV,   desc="Get Data and set Invalid gsn from LCPM";
    GSN_GETS,   desc="Get Data and set shared gsn from LCPM";
    GSN_GETRELEASE,    desc="Get Data and release gsn from LCPM";
    GSN_NCGETRELEASE,    desc="nocache addr Get Data and release gsn from LCPM";
    GSN_RELEASE,    desc="Release gsn from LCPM";

    // internal generated request
    WrVictimBlk_R,  desc="Scache cache line Replacement", format="!r";
    
    //Replacement
    EvictLocalBlk_R,  desc="L0 Replacement, Scache cache line Replacement", format="!r";
    EvictECacheBlk_R,  desc="Scache cache line Replacement", format="!r";

    //FLUSH
    EvictGlobalBlk_R,  desc="Scache cache line Replacement", format="!r";

    //Load or Store missed Scache 
    //ReadMissed,    desc="读指令、数据不命中Scache, ReadBlkI、ReadBlkIDVic、FetchBlkI、ReadBlk、ReadBlkDVic、ReadBlkMod、ReadBlkModDVic";
    //StoreMissed,    desc="写数据不命中Scache，ShareToDirty、ReadBlkMod、ReadBlkModDVic";
    
    //rsp for gsn(rq2), for processor
    Data_Response,               desc="Data for processor";
    NoData_Response,         desc="Data for processor, but not for storage";

    //ack for grq(rq1), for processor
    ReadData_Ack,    desc="Ack envents for FetchBlkI,IORead";
    ReadNCData_Ack,  desc="Ack events for ReadNCBlk"
    ReadDataShare_Ack,    desc="Ack for ReadBlkI,ReadBlkIDVic,ReadBlk,ReadBlkDVic";
    ReadDataDirty_Ack,    desc="ReadBlkMod,ReadBlkDVic";
    ChangeToDirtySuccess_Ack,    desc="ShareToDirty";
    ChangeToDirtyFail_Ack,    desc="ShareToDirty fail, EvictECacheBlk,EvictLocalBlk,EvictECacheBlk";
    WriteComplete_Ack,    desc="WrVictimBlk,IOWrite";
    WriteNCComplete_Ack,   desc="WriteNCBlk, WriteNCComplete_Ack";
    RequestComplete_Ack,    desc="";
    IllegalAddr_Ack,    desc="地址非法";
    INTReq_Ack,    desc="向核心发送的中断请求";

    // Prefetch events (generated by prefetcher)
    PF_L0_Replacement, desc="L0 Replacement caused by pretcher", format="!pr";

    ECFetchBlk_R,         desc="Load request from prefetcher";
    ECFetchBlkMod_R,       desc="Instruction fetch request from prefetcher";
    PF_Bad_Addr,     desc="Throw away prefetch request due to bad address generation";
  }

  // TYPES

  // CacheEntry
  structure(Entry, desc="...", interface="AbstractCacheEntry" ) {
    State CacheState,        desc="cache state";
    DataBlock DataBlk,       desc="data for the block";
    bool Dirty, default="false",   desc="data is dirty";
    bool isPrefetched, default="false", desc="Set if this block was prefetched";
  }

  // TBE fields
  structure(TBE, desc="...") {
    Addr addr,              desc="Physical address for this TBE";
    State TBEState,        desc="Transient state";
    DataBlock DataBlk,                desc="Buffer for the data block";
    bool Dirty, default="false",   desc="data is dirty";
    int pendingAcks, default="0", desc="number of pending acks";
  }

  structure(TBETable, external="yes") {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
    TBE getNullEntry();
  }

  TBETable TBEs, template="<L0Cache_TBE>", constructor="m_number_of_TBEs";

  Tick clockEdge();
  Cycles ticksToCycles(Tick t);
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpBuffers(Addr a);
  void wakeUpAllBuffers(Addr a);
  void profileMsgDelay(int virtualNetworkType, Cycles c);
  MachineID mapAddressToMachine(Addr addr, MachineType mtype);

  // inclusive cache returns L0 entries only
  Entry getCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry Scache_entry := static_cast(Entry, "pointer", Scache[addr]);
    if(is_valid(Scache_entry)) {
      return Dcache_entry;
    }
  }

  Entry getSCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry Scache_entry := static_cast(Entry, "pointer", Scache[addr]);
    return Scache_entry;
  }

  State getState(TBE tbe, Entry cache_entry, Addr addr) {
    assert((Scache.isTagPresent(addr) && Icache.isTagPresent(addr)) == false);

    if(is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.CacheState;
    }
    return State:I;
  }

  void setState(TBE tbe, Entry cache_entry, Addr addr, State state) {
    assert((Scache.isTagPresent(addr)) == false);

    // MUST CHANGE
    if(is_valid(tbe)) {
      tbe.TBEState := state;
    }

    if (is_valid(cache_entry)) {
      cache_entry.CacheState := state;
    }
  }

  AccessPermission getAccessPermission(Addr addr) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      DPRINTF(RubySlicc, "%s\n", L0Cache_State_to_permission(tbe.TBEState));
      return L0Cache_State_to_permission(tbe.TBEState);
    }

    Entry cache_entry := getCacheEntry(addr);
    if(is_valid(cache_entry)) {
      DPRINTF(RubySlicc, "%s\n", L0Cache_State_to_permission(cache_entry.CacheState));
      return L0Cache_State_to_permission(cache_entry.CacheState);
    }

    DPRINTF(RubySlicc, "%s\n", AccessPermission:NotPresent);
    return AccessPermission:NotPresent;
  }

  void functionalRead(Addr addr, Packet *pkt) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      testAndRead(addr, tbe.DataBlk, pkt);
    } else {
      testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);
    }
  }

  int functionalWrite(Addr addr, Packet *pkt) {
    int num_functional_writes := 0;

    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.DataBlk, pkt);
      return num_functional_writes;
    }

    num_functional_writes := num_functional_writes +
        testAndWrite(addr, getCacheEntry(addr).DataBlk, pkt);
    return num_functional_writes;
  }

  void setAccessPermission(Entry cache_entry, Addr addr, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.changePermission(L0Cache_State_to_permission(state));
    }
  }

//davi added
  int getEvictType(Addr addr){
    return(addr>>29&0x01);
  }

  int isCached(Addr addr){
     return(addr>>48&0x01);
  }

//david modify
  Event mandatory_request_type_to_event(RubyRequestType type, Addr addr, bool is_hit, bool is_vic) {
    if (type == RubyRequestType:LD) {
      if(isCached(addr)){
         if(is_vic)
            return Event:ReadBlkDVic;
         else
            return Event:Load;
      }else{
            return Event:ReadNCBlk;
      }
    }else if (type == RubyRequestType:IFETCH) {
        if(is_vic)
          return Event:ReadBlkIDVic;
        else
          return Event:Ifetch;
    }else if ((type == RubyRequestType:ST) || (type == RubyRequestType:ATOMIC)
               || (type == RubyRequestType:Store_Conditional)) {
                if(isCached(addr)){
                    if(is_vic){
                        return Event:ReadBlkModDVic;
                    }else
                        return Event:Store;                    
                }else 
                      return Event:WriteNCBlk;                
    }else{
          error("Invalid RubyRequestType");
         }
  }

  Event prefetch_request_type_to_event(RubyRequestType type) {
    if (type == RubyRequestType:LD || type == RubyRequestType:IFETCH) {
      return Event:ECFetchBlk;
    } else if (type == RubyRequestType:ST) {
      return Event:ECFetchBlkMod;
    } else {
      error("Invalid RubyRequestType");
    }
  }

  int getPendingAcks(TBE tbe) {
    return tbe.pendingAcks;
  }

  out_port(requestNetwork_out, CoherenceMsg, bufferToL1);
  out_port(optionalQueue_out, RubyRequest, prefetchQueue);

  void enqueuePrefetch(Addr address, RubyRequestType type) {
    enqueue(optionalQueue_out, RubyRequest, 1) {
      out_msg.LineAddress := address;
      out_msg.Type := type;
      out_msg.Prefetch := PrefetchBit:Yes;
      out_msg.AccessMode := RubyAccessMode:Supervisor;
    }
  }

  // Prefetch queue between the controller and the prefetcher
  // As per Spracklen et al. (HPCA 2005), the prefetch queue should be
  // implemented as a LIFO structure.  The structure would allow for fast
  // searches of all entries in the queue, not just the head msg. All
  // msgs in the structure can be invalidated if a demand miss matches.
  in_port(optionalQueue_in, RubyRequest, prefetchQueue, desc="...", rank = 2) {
    if (optionalQueue_in.isReady(clockEdge())) {
      peek(optionalQueue_in, RubyRequest) {
        // first check for valid address
        MachineID mid := mapAddressToMachine(in_msg.LineAddress, MachineType:Directory);
        NodeID nid := machineIDToNodeID(mid);
        int nidint := IDToInt(nid);
        int numDirs := machineCount(MachineType:Directory);
        if (nidint >= numDirs) {
          Entry cache_entry := static_cast(Entry, "pointer", Scache.getNullEntry());
          TBE tbe := TBEs.getNullEntry();
          trigger(Event:PF_Bad_Addr, in_msg.LineAddress, cache_entry, tbe);
        } else if (in_msg.Type == RubyRequestType:IFETCH) {
          // Instruction Prefetch
          Entry icache_entry := getSCacheEntry(in_msg.LineAddress);
          if (is_valid(icache_entry)) {
            // The block to be prefetched is already present in the
            // cache. This request will be made benign and cause the
            // prefetch queue to be popped.
            trigger(prefetch_request_type_to_event(in_msg.Type),
                    in_msg.LineAddress,
                    icache_entry, TBEs[in_msg.LineAddress]);
          }

          // Check to see if it is in the L0-D
          Entry cache_entry := getSCacheEntry(in_msg.LineAddress);
          if (is_valid(cache_entry)) {
            // The block is in the wrong L0 cache. We should drop
            // this request.
            trigger(prefetch_request_type_to_event(in_msg.Type),
                    in_msg.LineAddress,
                    cache_entry, TBEs[in_msg.LineAddress]);
          }

          if (Icache.cacheAvail(in_msg.LineAddress)) {
            // L0-I does't have the line, but we have space for it
            // in the L0-I so let's see if the L1 has it
            trigger(prefetch_request_type_to_event(in_msg.Type),
                    in_msg.LineAddress,
                    icache_entry, TBEs[in_msg.LineAddress]);
          } else {
            // No room in the L0-I, so we need to make room in the L0-I
            Addr addr := Icache.cacheProbe(in_msg.LineAddress);
            check_on_cache_probe(optionalQueue_in, addr);

            trigger(Event:PF_L0_Replacement, addr,
                    getICacheEntry(addr),
                    TBEs[addr]);
          }
        } else {
          // Data prefetch
          Entry cache_entry := getSCacheEntry(in_msg.LineAddress);
          if (is_valid(cache_entry)) {
            // The block to be prefetched is already present in the
            // cache. This request will be made benign and cause the
            // prefetch queue to be popped.
            trigger(prefetch_request_type_to_event(in_msg.Type),
                    in_msg.LineAddress,
                    cache_entry, TBEs[in_msg.LineAddress]);
          }

          // Check to see if it is in the L0-I
          Entry icache_entry := getICacheEntry(in_msg.LineAddress);
          if (is_valid(icache_entry)) {
            // The block is in the wrong L0. Just drop the prefetch
            // request.
            trigger(prefetch_request_type_to_event(in_msg.Type),
                    in_msg.LineAddress,
                    icache_entry, TBEs[in_msg.LineAddress]);
          }

          if (Scache.cacheAvail(in_msg.LineAddress)) {
            // L0-D does't have the line, but we have space for it in
            // the L0-D let's see if the L1 has it
            trigger(prefetch_request_type_to_event(in_msg.Type),
                    in_msg.LineAddress,
                    cache_entry, TBEs[in_msg.LineAddress]);
          } else {
            // No room in the L0-D, so we need to make room in the L0-D
            Addr addr := Scache.cacheProbe(in_msg.LineAddress);
            check_on_cache_probe(optionalQueue_in, addr);

            trigger(Event:PF_L0_Replacement, addr,
                    getSCacheEntry(addr),
                    TBEs[addr]);
          }
        }
      }
    }
  }

  // Messages for this L0 cache from the L1 cache
  in_port(messgeBuffer_in, CoherenceMsg, bufferFromL1, rank = 1) {
    if (messgeBuffer_in.isReady(clockEdge())) {
      peek(messgeBuffer_in, CoherenceMsg, block_on="addr") {
        assert(in_msg.Dest == machineID);
        TBE tbe := TBEs[in_msg.addr];

        Entry cache_entry := getCacheEntry(in_msg.addr);
        
        if(in_msg.Class == CoherenceClass:ReadData) {
          {
            if(isCached(in_msg.addr))
                    trigger(Event:ReadData_Ack, in_msg.addr, cache_entry, tbe);
            else{
                    tbe.DataBlk := in_msg.DataBlk;
                    trigger(Event:ReadNCData_Ack, in_msg.addr, cache_entry, tbe);
                }
          }
        } else if(in_msg.Class == CoherenceClass:ReadDataShare) {
            trigger(Event:ReadDataShare_Ack, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Class == CoherenceClass:ReadDataDirty) {
            trigger(Event:ReadDataDirty_Ack, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Class == CoherenceClass:ChangeToDirtySuccess) {
            trigger(Event:ChangeToDirtySuccess_Ack, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Class == CoherenceClass:ChangeToDirtyFail_Ack) {
            trigger(Event:ChangeToDirtyFail_Ack, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Class == CoherenceClass:GetR) {
            if(isCached(in_msg.addr))
                trigger(Event:GSN_GETRELEASE, in_msg.addr, cache_entry, tbe);
            else
                 trigger(Event:GSN_NCGETRELEASE, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Class == CoherenceClass:PutI) {
            trigger(Event:GSN_PUTINV, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Class == CoherenceClass:WriteComplete) {
          if(isCached(in_msg.addr))
            trigger(Event:WriteComplete_Ack, in_msg.addr, cache_entry, tbe);
          else
            trigger(Event:WriteNCComplete_Ack, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Class == CoherenceClass:GetI) {
          trigger(Event:GSN_GETINV, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Class == CoherenceClass:GetS) {
          trigger(Event:GSN_GETS, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Class == CoherenceClass:GETX ||
                   in_msg.Class == CoherenceClass:UPGRADE) {
          // upgrade transforms to GETX due to race
          trigger(Event:Fwd_GETX, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Class == CoherenceClass:Release) {
          trigger(Event:GSN_RELEASE, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Class == CoherenceClass:RequestComplete) {
          trigger(Event:RequestComplete_Ack, in_msg.addr, cache_entry, tbe);
        } else {
          error("Invalid forwarded request type");
        }
      }
    }
  }

 // Mandatory Queue betweens Node's CPU and it's L0 caches 节点的CPU与其L0缓存之间的强制队列
  in_port(mandatoryQueue_in, RubyRequest, mandatoryQueue, desc="...", rank = 0) {
        if (mandatoryQueue_in.isReady(clockEdge())) {
            peek(mandatoryQueue_in, RubyRequest, block_on="LineAddress") {
                // Check for data access to blocks in I-cache and ifetchs to blocks in D-cache
                // 检查对I-cache中的块的数据访问和对D-cache的块的ifetch
                if (in_msg.Type == RubyRequestType:IFETCH) {
                    // ** INSTRUCTION ACCESS  指令存取***
                    Entry Scache_entry := getSCacheEntry(in_msg.LineAddress);
                    if (is_valid(Scache_entry)) {   //Scache条目有效
                        // The tag matches for the L0, so the L0 asks the L2 for it.
                        // 标签与L0匹配，因此L0向L2请求它。
                        //触发的事件：Ifetch
                        trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress, true, false), 
                            in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                    } else { //Scache条目无效
                        //Scache missed  SCache不命中  （是否有空间）
                        if (Scache.cacheAvail(in_msg.LineAddress)) {
                            // L0 does't have the line, but we have space for it
                            // in the L0 so let's see if the L2 has it
                            // L0没有线条，但我们在L0中有空间，所以让我们看看L2是否有线条
                            //触发的事件：Ifetch 
                            trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress,false, false), 
                                in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                        } else {
                            // No room in the L0, so we need to make room in the L0
                            // Check if the line we want to evict is not locked
                            // L0中没有空间，所以我们需要在L0中腾出空间。检查我们要驱逐的线路是否未锁定
                            Addr addr := Scache.cacheProbe(in_msg.LineAddress);  //准备淘汰的地址
                            check_on_cache_probe(mandatoryQueue_in, addr);  //地址是否在缓冲队列中
                            Scache_entry := getSCacheEntry(addr);           
                            //触发的事件：ReadBlkDVic
                            trigger(mandatory_request_type_to_event(in_msg.Type, addr ,false, true), 
                                addr, Scache_entry, TBEs[in_msg.LineAddress]);
                        }
                    }
                //Type：刷新
                } else if(in_msg.Type == RubyRequestType:REPLACEMENT) {
                    // No room in the L1, so we need to make room in the L0
                    // Check if the line we want to evict is not locked
                    // L1中没有空间，所以我们需要在L0中腾出空间。检查我们要驱逐的线路是否未锁定
                    Entry Scache_entry := getSCacheEntry(in_msg.LineAddress);
                    Addr addr := Scache.cacheProbe(in_msg.LineAddress);
                    check_on_cache_probe(mandatoryQueue_in, addr);
                    if(getEvictType(addr))
                        //触发事件:EvictECacheBlk_R
                        trigger(Event:EvictECacheBlk_R, in_msg.LineAddress, Scache_entry , TBEs[in_msg.LineAddress]);
                    else {
                        //Scache条目有效
                        if(is_valid(Scache_entry))
                            //触发事件:EvictLocalBlk_R
                            trigger(Event:EvictLocalBlk_R, addr, getSCacheEntry(addr), TBEs[addr]);
                    }
                //Type:刷新请求类型
                } else if(in_msg.Type == RubyRequestType:FLUSH) {
                    if(is_valid(Scache_entry))
                        //触发事件:EvictGlobalBlk_R
                        trigger(Event:EvictGlobalBlk_R, addr, getSCacheEntry(addr), TBEs[addr]);
                } else {//其他类型
                    // *** DATA ACCESS ***
                    // 不可Cache
                    if(!isCached(in_msg.LineAddress)) {
                        //可能触发的事件:  ReadNCBlk/WriteNCBlk  判断type:LD/ST  
                        trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress, true, false), 
                            in_msg.LineAddress, Scache_entry, tbe);
                    } else {
                        Entry Scache_entry := getSCacheEntry(in_msg.LineAddress);
                        // early out for failed store conditionals
                        // 及早发现失败的存储条件
                        if (in_msg.Type == RubyRequestType:Store_Conditional) { //不用管 ARM
                            //TODO:这个判断条件是啥意思
                            if (!sequencer.llscCheckMonitor(in_msg.LineAddress)) {
                                //触发的事件:Failed_SC
                                trigger(Event:Failed_SC, in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                            }
                        }
                        if (is_valid(Scache_entry)) {//有效--》命中
                            // The tag matches for the L0, so the L0 ask the L1 for it
                            // 标签与L0匹配，因此L0向L1请求它
                            // 触发的事件:  Load/Store_hit  判断type:LD/ST 
                            trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress, true, false), 
                                in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                        } else {
                            // if the request is not valid, the store conditional will fail
                            // 如果请求无效，存储条件将失败
                            if (in_msg.Type == RubyRequestType:Store_Conditional) {//不用管
                                // if the line is not valid, it can't be locked
                                // 如果该行无效，则无法锁定
                                //  触发的事件: Failed_SC
                                //TODO:这个和上面第二个的触发有什么区别？
                                trigger(Event:Failed_SC, in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                            } else {
                                if (Scache.cacheAvail(in_msg.LineAddress)) {    //Cache是否有空间
                                    // L1 does't have the line, but we have space for it
                                    // in the L0 let's see if the L1 has it
                                    // L1没有线条，但我们在L0中有空间，让我们看看L1是否有空间
                                    // 触发的事件:  Load/Store_miss   判断type:LD/ST 
                                    trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.LineAddress,false, false), 
                                        in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                                } else {
                                    // No room in the Scache, so we need to make room in the Scache
                                    // Check if the line we want to evict is not locked
                                    // Scache没有空间，所以我们需要在Scache腾出空间检查我们要驱逐的线路是否没有锁定
                                    Addr addr := Scache.cacheProbe(in_msg.LineAddress);
                                    check_on_cache_probe(mandatoryQueue_in, addr);
                                    Scache_entry := getSCacheEntry(addr);
                                    // 触发的事件:ReadBlkDVic/ReadBlkModDVic    判断type:LD/ST 
                                    trigger(mandatory_request_type_to_event(in_msg.Type, addr, false, true), 
                                        in_msg.LineAddress, Scache_entry, TBEs[in_msg.LineAddress]);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

  // ACTIONS
  action(a_issueGETS, "a", desc="Issue GetS") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:GetS;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(a_issueReadBlk, "a", desc="Issue ReadBlk") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:ReadBlk;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(a_issueReadBlkDVic, "a", desc="Issue ReadBlkDVic") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := in_msg.LineAddress;
        out_msg.Class := CoherenceClass:ReadBlkDVic;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(a_issueReadBlkMod, "a", desc="Issue ReadBlkMod") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:ReadBlkMod;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

    action(a_issueReadNCBlk, "a", desc="Issue ReadBlk") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:ReadNCBlk;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.request_size := in_msg.Size;
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
        out_msg.request_size := in_msg.Size;
      }
    }
  }

  action(a_issueReadBlkI, "a", desc="Issue ReadBlkI") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := in_msg.LineAddress;
        out_msg.Class := CoherenceClass:ReadBlkI;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(a_issueReadBlkIDVic, "ad", desc="Issue ReadBlkIDVic") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := in_msg.LineAddress;
        out_msg.Class := CoherenceClass:ReadBlkIDVic;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }


  action(b_issueReadBlkMod, "b", desc="Issue ReadBlkMod") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:ReadBlkMod;
        out_msg.Sender := machineID;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);

        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(b_issueReadBlkModDVic, "b", desc="Issue ReadBlkMod") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := in_msg.LineAddress;
        out_msg.Class := CoherenceClass:ReadBlkModDVic;
        out_msg.Sender := machineID;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);

        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                in_msg.LineAddress, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(b_issueWriteNCBlk, "b", desc="Issue WriteNCBlk") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:WriteNCBlk;
        out_msg.Sender := machineID;
        //davi add 
        out_msg.request_size := in_msg.Size;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);

        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

//davi
  action(b_issueDataResponse, "bdr", desc="Issue DataResponse"){
    enqueue(requestNetwork_out, CoherenceMsg, request_latency){
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:DataResponse;
        out_msg.Sender := machineID;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);

        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        if(isCached(address)){
                if(is_valid(cache_entry)){
                        out_msg.DataBlk := cache_entry.DataBlk;
                    } else {
                        out_msg.DataBlk := tbe.DataBlk;
                    }
            }
        else{
                out_msg.DataBlk := tbe.DataBlk;
            }
    }

  }

  action(b_issueShareToDirty, "b", desc="Issue ShareToDirty") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:ShareToDirty;
        out_msg.Sender := machineID;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);

        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(elb_issueEvictLocalBlk, "elb", desc="Issue EvictLocalBlk") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:EvictLocalBlk;
        out_msg.Sender := machineID;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);

        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(ecb_issueEvictECacheBlk, "ecb", desc="Issue EvictECacheBlk") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:EvictECacheBlk;
        out_msg.Sender := machineID;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);

        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }


  action(f_sendDataToL1, "f", desc="Send data to the L1 cache") {
    enqueue(requestNetwork_out, CoherenceMsg, response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Class := CoherenceClass:DataResponse;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Sender := machineID;
      out_msg.Dest := createMachineID(MachineType:L1Cache, version);
      out_msg.MessageSize := MessageSizeType:Writeback_Data;
    }
    cache_entry.Dirty := false;
  }

  action(fi_sendInvAck, "fi0", desc="Send data to the L1 cache") {
    peek(messgeBuffer_in, CoherenceMsg) {
      enqueue(requestNetwork_out, CoherenceMsg, response_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:NoDataResponse;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        out_msg.MessageSize := MessageSizeType:Response_Control;
      }
    }
  }

  action(fi_sendGetInvAck, "fi1", desc="Send data to the L1 cache") {
    peek(messgeBuffer_in, CoherenceMsg) {
      enqueue(requestNetwork_out, CoherenceMsg, response_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:DataResponse;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        out_msg.MessageSize := MessageSizeType:Response_Control;
        out_msg.DataBlk := cache_entry.DataBlk;
      }
    }
  }

  action(forward_eviction_to_cpu, "\cc", desc="Send eviction information to the processor") {
    if (send_evictions && isCached(address)) {
      DPRINTF(RubySlicc, "Sending invalidation for %#x to the CPU\n", address);
      sequencer.evictionCallback(address);
    }
  }


  action(h_load_hit, "hd", desc="Notify sequencer the load completed (cache hit)") {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    Scache.setMRU(cache_entry);
    sequencer.readCallback(address, cache_entry.DataBlk);
  }

  action(h_ifetch_hit, "hi", desc="Notify sequencer the ifetch completed (cache hit)") {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    Scache.setMRU(cache_entry);
    sequencer.readCallback(address, cache_entry.DataBlk);
  }

  // The action name uses a counterintuitive _hit prefix when it is only
  // called due to a cache miss. It is technically now a hit after having
  // serviced the miss.
  action(hx_load_hit, "hxd", desc="Notify sequencer the load completed (cache miss)") {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    Scache.setMRU(cache_entry);
    sequencer.readCallback(address, cache_entry.DataBlk, true);
  }

  action(nc_load_hit, "ncd", desc="Notify sequencer the load completed (cache miss)") {
    DPRINTF(RubySlicc, "%s\n", tbe.DataBlk);
    sequencer.readCallback(address,  tbe.DataBlk, true);
  }

  // The action name uses a counterintuitive _hit prefix when it is only
  // called due to a cache miss. It is technically now a hit after having
  // serviced the miss.
  action(hx_ifetch_hit, "hxi", desc="Notify sequencer the ifetch completed (cache miss)") {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    Icache.setMRU(cache_entry);
    sequencer.readCallback(address, cache_entry.DataBlk, true);
  }

  action(hh_store_hit, "\h", desc="Notify sequencer that store completed (cache hit)") {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    Dcache.setMRU(cache_entry);
    sequencer.writeCallback(address, cache_entry.DataBlk);
    cache_entry.Dirty := true;
  }

  // The action name uses a counterintuitive _hit prefix when it is only
  // called due to a cache miss. It is technically now a hit after having
  // serviced the miss.
  action(hhx_store_hit, "\hx", desc="Notify sequencer that store completed (cache miss)") {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    Scache.setMRU(cache_entry);
    sequencer.writeCallback(address, cache_entry.DataBlk, true);
    cache_entry.Dirty := true;
  }

  action(nc_hhx_store_hit, "\nchx", desc="Notify sequencer that store completed (cache miss)") {
    assert(is_valid(tbe));
    DPRINTF(RubySlicc, "%s\n", tbe.DataBlk);
    sequencer.writeCallback(address, tbe.DataBlk, true);
  }

  action(i_allocateTBE, "i", desc="Allocate TBE (number of invalidates=0)") {
    check_allocate(TBEs);
    assert(is_valid(cache_entry));
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
    tbe.Dirty := cache_entry.Dirty;
    tbe.DataBlk := cache_entry.DataBlk;
  }

//davi
  action(i_uncache_allocateTBE, "iun", desc="uncached Allocate TBE (number of invalidates=0)") {
    peek(mandatoryQueue_in, RubyRequest) {
        check_allocate(TBEs);
        TBEs.allocate(in_msg.LineAddress);
        set_tbe(TBEs[in_msg.LineAddress]);
        tbe.DataBlk := in_msg.WTData;
    }
  }

  action(issue_evict, "isev", desc="issue vic info to L1"){
    enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        //Addr addr := Scache.cacheProbe(address);
       // check_on_cache_probe(mandatoryQueue_in, addr);

        assert(is_valid(cache_entry));
        out_msg.addr := address;
        if(cache_entry.Dirty)
            out_msg.Class := CoherenceClass:WrVictimBlk;
        else
            out_msg.Class := Nop;
        out_msg.Dirty := cache_entry.Dirty;
        out_msg.Sender:= machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);  
        //out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache, l2_select_low_bit, l2_select_num_bits, clusterID));
        out_msg.MessageSize := MessageSizeType:Writeback_Control;

        check_allocate(TBEs);
        TBEs.allocate(addr);
        set_tbe(TBEs[addr]);
        TBE tbe_evic := TBEs[addr];
        tbe_evic.DataBlk := cache_entry.DataBlk;
        
        Scache.deallocate(addr);
        unset_cache_entry();
      }
  }

  action(k_popMandatoryQueue, "k", desc="Pop mandatory queue") {
    mandatoryQueue_in.dequeue(clockEdge());
  }

  action(l_popRequestQueue, "l",
         desc="Pop incoming request queue and profile the delay within this virtual network") {
    Tick delay := messgeBuffer_in.dequeue(clockEdge());
    profileMsgDelay(2, ticksToCycles(delay));
  }

  action(o_popIncomingResponseQueue, "o",
         desc="Pop Incoming Response queue and profile the delay within this virtual network") {
    Tick delay := messgeBuffer_in.dequeue(clockEdge());
    profileMsgDelay(1, ticksToCycles(delay));
  }

  action(s_deallocateTBE, "s", desc="Deallocate TBE") {
      if(is_valid(tbe)){
          TBEs.deallocate(address);
          unset_tbe();
      }
  }

  action(u_writeDataToCache, "u", desc="Write data to cache") {
    peek(messgeBuffer_in, CoherenceMsg) {
        assert(is_valid(cache_entry));
        cache_entry.DataBlk := in_msg.DataBlk;    
    }
  }

  action(u_writeInstToCache, "ui", desc="Write data to cache") {
    peek(messgeBuffer_in, CoherenceMsg) {
      assert(is_valid(cache_entry));
      cache_entry.DataBlk := in_msg.DataBlk;
    }
  }

  action(ff_deallocateCacheBlock, "\f",
         desc="Deallocate L1 cache block.") {
      if(isCached(address)){
          if(is_valid(cache_entry)){
              cache.deallocate(address);
              unset_cache_entry();
          }

      }
  }

  action(oo_allocateSCacheBlock, "\o", desc="Set L1 D-cache tag equal to tag of block B") {
    peek(mandatoryQueue_in, RubyRequest) {
      if (is_invalid(getSCacheEntry(in_msg.LineAddress))) {
        set_cache_entry(Scache.allocate(in_msg.LineAddress, new Entry));
      }
    }
  }


  action(z_stallAndWaitMandatoryQueue, "\z", desc="Stall cpu request queue") {
    stall_and_wait(mandatoryQueue_in, address);
  }

  action(kd_wakeUpDependents, "kd", desc="Wake-up dependents") {
    wakeUpAllBuffers(address);
  }

  action(uu_profileInstMiss, "\ui", desc="Profile the demand miss") {
    Icache.profileDemandMiss();
  }

  action(uu_profileInstHit, "\uih", desc="Profile the demand hit") {
    Icache.profileDemandHit();
  }

  action(uu_profileDataMiss, "\ud", desc="Profile the demand miss") {
    Scache.profileDemandMiss();
  }

  action(uu_profileDataHit, "\udh", desc="Profile the demand hit") {
    Dcache.profileDemandHit();
  }

  // store conditionals

  action(hhc_storec_fail, "\hc",
         desc="Notify sequencer that store conditional failed") {
    sequencer.writeCallbackScFail(address, cache_entry.DataBlk);
  }

  // prefetching
  action(pa_issueEctechBlk, "pa", desc="Issue prefetch GETS") {
    peek(optionalQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:ECFetchBlk;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(pb_issueEctechBlkMod, "pb", desc="Issue prefetch GETS") {
    peek(optionalQueue_in, RubyRequest) {
      enqueue(requestNetwork_out, CoherenceMsg, request_latency) {
        out_msg.addr := address;
        out_msg.Class := CoherenceClass:ECFetchBlkMod;
        out_msg.Sender := machineID;
        out_msg.Dest := createMachineID(MachineType:L1Cache, version);
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Dest);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }


  action(pq_popPrefetchQueue, "\pq", desc="Pop the prefetch request queue") {
    optionalQueue_in.dequeue(clockEdge());
  }

  action(mp_markPrefetched, "mp", desc="Write data from response queue to cache") {
      assert(is_valid(cache_entry));
      cache_entry.isPrefetched := true;
  }

  action(po_observeMiss, "\po", desc="Inform the prefetcher about a cache miss") {
    peek(mandatoryQueue_in, RubyRequest) {
      if (enable_prefetch) {
        prefetcher.observeMiss(in_msg.LineAddress, in_msg.Type);
      }
    }
  }

  action(ppm_observePfMiss, "\ppm",
         desc="Inform the prefetcher about a cache miss with in-flight prefetch") {
    peek(mandatoryQueue_in, RubyRequest) {
      prefetcher.observePfMiss(in_msg.LineAddress);
    }
  }

  action(pph_observePfHit, "\pph",
         desc="Inform the prefetcher if a cache hit was the result of a prefetch") {
    peek(mandatoryQueue_in, RubyRequest) {
      if (cache_entry.isPrefetched) {
        prefetcher.observePfHit(in_msg.LineAddress);
        cache_entry.isPrefetched := false;
      }
    }
  }

  action(z_stallAndWaitOptionalQueue, "\pz", desc="recycle prefetch request queue") {
    stall_and_wait(optionalQueue_in, address);
  }

  //*****************************************************
  // TRANSITIONS
  //*****************************************************

  // Transitions for Load/Store/Replacement/WriteBack from transient states
  transition({IMD, ISD, SMA, PF_FA, PF_WA, IEA}, {Load, Ifetch, Store, ReadBlkIDVic,ReadNCBlk,ReadBlkDVic,WriteNCBlk}) {
    z_stallAndWaitMandatoryQueue;
  }

  // Transitions from Idle
  transition(I, Load, ISD) {
    oo_allocateSCacheBlock;
    i_allocateTBE;
    a_issueReadBlk;
    uu_profileDataMiss;  //记录更新miss状态
    po_observeMiss;  //通知预取器cache miss
    k_popMandatoryQueue;  //弹出event
  }

   transition({S,M}, Load) {
    h_load_hit;
    uu_profileDataHit;
    pph_observePfHit;
    k_popMandatoryQueue;
  }

  transition(I, ReadBlkIDVic, ISD) {
    a_issueReadBlkIDVic;
    issue_evict;  //send evict to lcpm & deallocate evict Scache & allocate tbe for evict addr, released in gets,release
    oo_allocateSCacheBlock; //for read
    i_uncache_allocateTBE; //for read, released in ISD->S
    uu_profileDataMiss;  //记录更新miss状态
    po_observeMiss;  //通知预取器cache miss
    k_popMandatoryQueue;  //弹出event
  }

  transition({I,M,S}, ReadNCBlk) {
    //oo_allocateSCacheBlock;
    i_uncache_allocateTBE;
    a_issueReadNCBlk;
    //uu_profileDataMiss;  //记录更新miss状态
    //po_observeMiss;  //通知预取器cache miss
    k_popMandatoryQueue;  //弹出request from cpu
  }

  transition(I, Ifetch, ISD) {
    oo_allocateSCacheBlock;
    i_allocateTBE;
    a_issueReadBlkI;
    uu_profileInstMiss;
    po_observeMiss;
    k_popMandatoryQueue;
  }

  transition({S,M}, Ifetch) {
    h_ifetch_hit;
    uu_profileInstHit;
    pph_observePfHit;
    k_popMandatoryQueue;
  }

  transition(I, ReadBlkDVic, ISD) {
    a_issueReadBlkDVic;
    issue_evict;  //send evict to lcpm & deallocate evict Scache & allocate tbe for evict addr
    oo_allocateSCacheBlock; //for read
    i_uncache_allocateTBE; //for read
    uu_profileDataMiss;  //记录更新miss状态
    po_observeMiss;  //通知预取器cache miss
    k_popMandatoryQueue;  //弹出event
  }

  transition(S, Store, SMA) {
    b_issueShareToDirty;
    uu_profileDataHit;
    pph_observePfHit;
    k_popMandatoryQueue;
  }

  transition({I,M,S}, WriteNCBlk) {
   // oo_allocateSCacheBlock;
    i_uncache_allocateTBE;
    b_issueWriteNCBlk;
    //uu_profileDataMiss;
  //  po_observeMiss;
    k_popMandatoryQueue;
  }

  transition({M,S}, EvictLocalBlk_R, IEA){
    i_allocateTBE;
    elb_issueEvictLocalBlk;
    k_popMandatoryQueue;
  }

  transition({I,M,S}, EvictECacheBlk_R){
    ecb_issueEvictECacheBlk;
    k_popMandatoryQueue;
  }

  transition(IEA, ChangeToDirtyFail_Ack, I){
    forward_eviction_to_cpu;
    s_deallocateTBE;
    ff_deallocateCacheBlock;
    o_popIncomingResponseQueue;
  }

  transition({I,M,S}, EvictGlobalBlk_R){
    ecb_issueEvictGlobalBlk;
    k_popMandatoryQueue;
  }

  transition({I,M,S}, ChangeToDirtyFail_Ack){
    forward_eviction_to_cpu;
    o_popIncomingResponseQueue;
  }
  
//davi Transitions from Modified
  transition({I,M,S},GSN_NCGETRELEASE){
    b_issueDataResponse;
   // ff_deallocateCacheBlock;
   // nc_hhx_store_hit;
    s_deallocateTBE;
    l_popRequestQueue;
  }

//cache line in S state, will not issue evict, just delateit 
  transition(M, GSN_RELEASE, I){
    fi_sendInvAck;
    //forward_eviction_to_cpu;
    ff_deallocateCacheBlock;
    s_deallocateTBE;
    l_popRequestQueue;
  }

  transition(M, GSN_GETRELEASE, I){
    b_issueDataResponse;
    //forward_eviction_to_cpu;
    ff_deallocateCacheBlock;
    s_deallocateTBE;
    l_popRequestQueue;
  }

  transition({M,S},GSN_PUTINV, I){
   // forward_eviction_to_cpu;
    fi_sendInvAck;
    ff_deallocateCacheBlock;
    l_popRequestQueue;
  }

  transition({M,S},GSN_GETINV, I){
   // forward_eviction_to_cpu;
    fi_sendGetInvAck;
    ff_deallocateCacheBlock;
    l_popRequestQueue;
  }

  transition({I,M,S},WriteNCComplete_Ack){
    nc_hhx_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
  }

  transition(I, Store, IMD) {
    oo_allocateSCacheBlock;
    i_allocateTBE;
    b_issueReadBlkMod;
    uu_profileDataMiss;
    po_observeMiss;
    k_popMandatoryQueue;
  }

  transition(I, ReadBlkModDVic, IMD){
    b_issueReadBlkModDVic;
    issue_evict;  //send evict to lcpm & deallocate evict Scache & allocate tbe for evict addr
    oo_allocateSCacheBlock; //for write
    i_uncache_allocateTBE; //for write
    uu_profileDataMiss;  //记录更新miss状态
    po_observeMiss;  //通知预取器cache miss
    k_popMandatoryQueue;  //弹出event
  }

  // Transitions from Shared
  transition({S,M}, Ifetch) {
    h_ifetch_hit;
    uu_profileInstHit;
    pph_observePfHit;
    k_popMandatoryQueue;
  }

  transition(M ,WriteComplete_Ack, I) {
    forward_eviction_to_cpu;
   //ff_deallocateCacheBlock; //has deleted in issue_evict
    s_deallocateTBE;
    o_popIncomingResponseQueue;
  }

  transition(S ,WriteComplete_Ack, I) {
    forward_eviction_to_cpu;
    //ff_deallocateCacheBlock; //has deleted in issue_evict
    s_deallocateTBE;
    o_popIncomingResponseQueue;
  }

  transition({S,M}, GSN_GETS, S) {
    f_sendDataToL1;
    l_popRequestQueue;
  }

  transition(ISD, ReadDataShare_Ack, S) {
    u_writeDataToCache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(ISD, ReadData_Ack, S) {
    u_writeDataToCache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

//uncached readback
  transition({I,S,M}, ReadNCData_Ack) {
    //u_writeDataToCache;
    nc_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

//davi
//sharetodirty hit in lcpm
  transition(SMA, ChangeToDirtySuccess_Ack, M) {
    //u_writeDataToCache;
    hhx_store_hit;
    o_popIncomingResponseQueue;
  }

//sharetodirty not hit in lcpm
  transition(SMA, ReadDataDirty_Ack, M) {
    u_writeDataToCache;
    hhx_store_hit;
    o_popIncomingResponseQueue;
  }

  transition(IMD, ReadDataDirty_Ack, M) {
    u_writeDataToCache;
    hhx_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }
  // store conditionals

  transition({I,S,M}, Failed_SC) {
    // IS,IM,SM don't handle store conditionals
    hhc_storec_fail;
    k_popMandatoryQueue;
  }

  // prefetcher

  transition({{IMD, ISD, SMA, PF_FA, PF_WA, IEA}, {ECFetchBlk_R, ECFetchBlkMod_R}) {
     z_stallAndWaitOptionalQueue;
  }

  transition({ECFetchBlk_R, ECFetchBlkMod_R}, {Load, Ifetch, Store, ReadBlkDVic,ReadBlkIDVic}) {
    z_stallAndWaitMandatoryQueue;
  }

  transition({S,M,ISD,IMD,IEA}, {ECFetchBlk_R, ECFetchBlkMod_R}) {
      pq_popPrefetchQueue;
  }

  transition(I, ECFetchBlk_R, PF_FA) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    pa_issueEctechBlk;
    pq_popPrefetchQueue;
  }

  transition(I, ECFetchBlkMod_R,PF_WA) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    pb_issueEctechBlkMod;
    pq_popPrefetchQueue;
  }

  transition(PF_FA, RequestComplete_Ack,I) {
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(PF_WA, RequestComplete_Ack,I) {
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(I, PF_Bad_Addr) {
    pq_popPrefetchQueue;
  }
}
